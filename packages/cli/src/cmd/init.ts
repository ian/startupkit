import { existsSync, readFileSync, writeFileSync } from "node:fs"
import path from "node:path"
import degit from "degit"
import inquirer from "inquirer"
import { replaceInFile } from "replace-in-file"
import { spinner } from "../lib/spinner"
import { exec } from "../lib/system"

export function parseEnvKeys(content: string): Set<string> {
	return new Set(
		content
			.split("\n")
			.filter((line) => line.includes("=") && !line.startsWith("#"))
			.map((line) => line.split("=")[0].trim())
	)
}

export function generateEnvContent(
	requiredEnv: Record<string, string>
): string {
	return `# Generated by StartupKit\n${Object.entries(requiredEnv)
		.map(([key, value]) => `${key}=${value}`)
		.join("\n")}\n`
}

export function mergeEnvContent(
	existingContent: string,
	requiredEnv: Record<string, string>
): { content: string; addedKeys: string[] } {
	const existingKeys = parseEnvKeys(existingContent)
	const missingEntries = Object.entries(requiredEnv).filter(
		([key]) => !existingKeys.has(key)
	)

	if (missingEntries.length === 0) {
		return { content: existingContent, addedKeys: [] }
	}

	const additions = missingEntries
		.map(([key, value]) => `${key}=${value}`)
		.join("\n")

	return {
		content: `${existingContent.trimEnd()}\n${additions}\n`,
		addedKeys: missingEntries.map(([k]) => k)
	}
}

export function slugify(input: string): string {
	return input
		.toLowerCase()
		.replace(/\s+/g, "-")
		.replace(/_/g, "-")
		.replace(/[^\w\-]+/g, "")
		.replace(/\-\-+/g, "-")
		.replace(/^-+|-+$/g, "")
}

export interface ResolveDestDirOptions {
	dir?: string
	key: string
	cwd: string
	promptedDirectory?: string
}

export function resolveDestDir(options: ResolveDestDirOptions): string {
	const { dir, key, cwd, promptedDirectory } = options

	if (dir) {
		return path.resolve(cwd, dir)
	}

	if (promptedDirectory !== undefined) {
		return path.resolve(cwd, promptedDirectory)
	}

	return path.resolve(cwd, key)
}

export function buildDegitSources(repoBase: string): {
	repoSource: string
	packagesSource: string
	storybookSource: string
} {
	if (repoBase.includes("#")) {
		const [userRepo, branch] = repoBase.split("#")
		const normalizedRepo = userRepo
			.replace(/\/templates\/repo$/, "")
			.replace(/\/templates\/packages$/, "")
		return {
			repoSource: `${normalizedRepo}/templates/repo#${branch}`,
			packagesSource: `${normalizedRepo}/templates/packages#${branch}`,
			storybookSource: `${normalizedRepo}/templates/apps/storybook#${branch}`
		}
	}
	const normalizedRepo = repoBase
		.replace(/\/templates\/repo$/, "")
		.replace(/\/templates\/packages$/, "")
	return {
		repoSource: `${normalizedRepo}/templates/repo`,
		packagesSource: `${normalizedRepo}/templates/packages`,
		storybookSource: `${normalizedRepo}/templates/apps/storybook`
	}
}

export async function init(props: {
	name?: string
	repoArg?: string
	dir?: string
}) {
	opener()

	// Step 1: Use provided name or prompt for project name
	let projectName = props.name
	let promptedForName = false
	if (!projectName) {
		const answer = await inquirer.prompt([
			{
				type: "input",
				name: "name",
				message: "What is the name of your project?",
				validate: (input: string) => (input ? true : "Project name is required")
			}
		])
		projectName = answer.name
		promptedForName = true
	}

	const slug = slugify(projectName)

	let key = slug
	if (promptedForName) {
		const { customizeKey } = await inquirer.prompt([
			{
				type: "confirm",
				name: "customizeKey",
				message: `Customize project key (${slug})?`,
				default: false
			}
		])
		if (customizeKey) {
			const keyAnswer = await inquirer.prompt({
				type: "input",
				name: "key",
				message: "Enter your project key:",
				default: slug,
				filter: (input: string) => slugify(input),
				transformer: (input: string) => slugify(input)
			})
			key = slugify(keyAnswer.key)
		}
	}

	// Step 2: Determine destination directory
	let promptedDirectory: string | undefined
	if (!props.dir && promptedForName) {
		const { directory } = await inquirer.prompt([
			{
				type: "input",
				name: "directory",
				message: "Where should we create the project?",
				default: `./${key}`,
				filter: (input: string) => input.trim()
			}
		])
		promptedDirectory = directory
	}

	const cwd = process.cwd()
	const destDir = resolveDestDir({
		dir: props.dir,
		key,
		cwd,
		promptedDirectory
	})

	const isCurrentDir = destDir === cwd

	// Step 3: Ask about Storybook
	let includeStorybook = false
	if (promptedForName) {
		const { addStorybook } = await inquirer.prompt([
			{
				type: "confirm",
				name: "addStorybook",
				message: "Would you like to add Storybook for component documentation?",
				default: true
			}
		])
		includeStorybook = addStorybook
	}

	// Step 4: Ask about package manager
	let packageManager = "pnpm"
	if (promptedForName) {
		const { pm } = await inquirer.prompt([
			{
				type: "list",
				name: "pm",
				message: "Which package manager would you like to use?",
				choices: [
					{ name: "pnpm (recommended)", value: "pnpm" },
					{ name: "bun", value: "bun" }
				],
				default: "pnpm"
			}
		])
		packageManager = pm
	}

	// --- USE DEGit TO CLONE THE REPO STRUCTURE AND PACKAGES ---
	const repoBase = props.repoArg || "ian/startupkit"
	const { repoSource, packagesSource, storybookSource } =
		buildDegitSources(repoBase)

	await spinner(
		`Cloning template into ${isCurrentDir ? "current directory" : destDir}`,
		async () => {
			const repoEmitter = degit(repoSource, {
				cache: false,
				force: true,
				verbose: false
			})
			await repoEmitter.clone(destDir)

			const packagesEmitter = degit(packagesSource, {
				cache: false,
				force: true,
				verbose: false
			})
			await packagesEmitter.clone(path.join(destDir, "packages"))

			if (includeStorybook) {
				const storybookEmitter = degit(storybookSource, {
					cache: false,
					force: true,
					verbose: false
				})
				await storybookEmitter.clone(path.join(destDir, "apps", "storybook"))
			}
		}
	)

	// Recursively replace all instances of PROJECT and PROJECT_VITE with slug
	await replaceInFile({
		files: `${destDir}/**/*`,
		from: [/PROJECT_VITE/g, /PROJECT/g],
		to: key,
		ignore: ["**/node_modules/**", "**/.git/**"],
		allowEmptyPaths: true
	})

	// Replace package manager placeholder in package.json
	const rootPackageJsonPath = path.join(destDir, "package.json")
	if (existsSync(rootPackageJsonPath)) {
		const packageJsonContent = readFileSync(rootPackageJsonPath, "utf8")
		const packageManagerVersion =
			packageManager === "pnpm" ? "10.28.2" : "1.1.27"
		const updatedContent = packageJsonContent
			.replace(
				/PACKAGE_MANAGER@PACKAGE_MANAGER_VERSION/g,
				`${packageManager}@${packageManagerVersion}`
			)
			.replace(/PACKAGE_MANAGER/g, packageManager)
		writeFileSync(rootPackageJsonPath, updatedContent)
	}

	// Replace package manager setup in GitHub workflow
	const workflowPath = path.join(
		destDir,
		".github/workflows/lint-typecheck.yml"
	)
	if (existsSync(workflowPath)) {
		const workflowContent = readFileSync(workflowPath, "utf8")
		let pmSetupBlock: string
		if (packageManager === "pnpm") {
			pmSetupBlock = `      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Use Node.js \${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: \${{ matrix.node-version }}
          cache: "pnpm"`
		} else {
			pmSetupBlock = `      - name: Install Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Use Node.js \${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: \${{ matrix.node-version }}`
		}
		const updatedWorkflow = workflowContent
			.replace(
				/# PACKAGE_MANAGER_SETUP_START[\s\S]*?# PACKAGE_MANAGER_SETUP_END/,
				pmSetupBlock
			)
			.replace(/PACKAGE_MANAGER/g, packageManager)
		writeFileSync(workflowPath, updatedWorkflow)
	}

	// Install dependencies
	await spinner(`Installing dependencies`, async () => {
		await exec(`${packageManager} install`, { cwd: destDir })
	})

	// Create or update .env.local with required keys
	const envLocal = path.join(destDir, ".env.local")
	const requiredEnv: Record<string, string> = {
		AUTH_SECRET: "FAKE1234567890123456789012345678901234567890",
		DATABASE_URL: `postgresql://localhost:5432/${key}?schema=public`
	}

	if (existsSync(envLocal)) {
		const existingContent = readFileSync(envLocal, "utf-8")
		const { content, addedKeys } = mergeEnvContent(existingContent, requiredEnv)
		if (addedKeys.length > 0) {
			writeFileSync(envLocal, content)
			console.log(`✅ Added missing env vars: ${addedKeys.join(", ")}`)
		}
	} else {
		writeFileSync(envLocal, generateEnvContent(requiredEnv))
		console.log("✅ Created .env.local")
	}

	// Generate AI agent instructions
	await spinner(`Generating AI agent instructions`, async () => {
		await exec(`${packageManager} agents.md`, { cwd: destDir })
	})

	console.log(`\nProject initialized at: ${isCurrentDir ? "." : destDir}`)
}

function opener() {
	// generated via https://ascii-generator.site
	console.log(`
                        ▓▒░░░▒▓         
                      ▓▒░░░░░░░▓        
                    ▓▒░░░▒▒░░░░         
                  ▓▒░░░▒▓▓░░░░          
                ▓▒▒▒▒▒▓ ▓░░░░           
              ▓▒▒▒▒▒   ▓░░░░            
            ▓▒▒▒▒▓    ▓░░░░             
          ▓▒▒▒▒▓      ░░░░              
         ▓▒▒▒▒▓     ▓░░░░▓              
          ▒▒▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒▒▒▒▒▓      
            ▓▓▓▓▓▓▓░░░▒▓▓▓▓▓▓▓▒▒▒▒      
                 ▓░░░▒      ▓▒▒▒▒▓      
                 ░░░▒     ▒▒▒▒▒▓        
               ▓░░░▒    ▒▒▒▒▒▓          
              ▓░░░▒  ▓▒▒▒▒▒▓            
             ▓░░░▒ ▓▒░░░▒▓              
            ▓░░░▒▓▒░░░▒▓                
            ▒░░░░░░░▒▓                  
             ▒░░░░▒▓                    
               ▓▓                       
                                        

  StartupKit - ${process.env.VERSION}
  The Zero to One Startup Framework
`)
}
